---
layout:     post
title:      java总结
category: blog
description: java各章节总结传送门，真门针对复习。
---

## java各章节总结传送门如下：

#### 集合：[http://blog.csdn.net/jiangxinyu/article/details/7886348](http://blog.csdn.net/jiangxinyu/article/details/7886348)

#### 多线程：[http://www.mamicode.com/info-detail-517008.html](http://www.mamicode.com/info-detail-517008.html)

## java复习题总结 

* Java的三大特性：封装、继承和多态。
  封装:
        首先,属性可用来描述同一类事物的特征, 行为可描述一类事物可做的操作,封装就是要把属于同一类事物的共性(包括属性与行为)归到一个类中,以方便使用.比如人这个东东,可用下面的方式封装:
人{
    年龄(属性一)
    身高(属性二)
    性别(属性三)

    做事(行为之一)
    走路(行为之二)
    说话(行为之三)
}

继承:
     由于封装,使得有共同特征的一类事物的所有描述信息都被归于一类之中,但我们知道,这并不是万能的,有些事物有共性,但还存在区别,比如教师,简单封装起来如下:
教师{
年龄(属性一)
身高(属性二)
性别(属性三)

做事(行为之一)
走路(行为之二)
说话(行为之三)

教书(行为之四)
}
上面对"教师"的封装,与对"人"的封装基本上差不多,只是多了一个特征行为:教书,
教师有与人一样的共性, 但我们不能说"人教书",也就是不能把教书封装到"人"之中去,教书是教师的特征行为之一.  为了省事地封装教师(代码的复用,这只是继承存在的原因之一), 可以让教师去继承人,如:
 教师 extends 人{
    教书(行为之三)
}
这样,我们就不用重新定义那些已经被"人"这一个类所封装的那些属性与行为了,而只需要使用继承的方式,在人的基础上拓展教师专有的行为,即"教书"即可把教师描述出来;这样的结果, 即是教师也同时拥有"人"之中所封装的一切属性与行为, 还拥有自己的特征行为"教书".

多态:
     多态的概念发展出来,是以封装和继承为基础的(其实我觉得抽象也应该算是面向对象的大特征之一,要封装,抽象是必须的)

简单的理解一下多态,比如:
人这个类,封装了很多人类共有的特性, 
教师是人的子类,继承了人的属性与行为,当然教师有自己的特征行为,比如教书授课;
学生是人的子类,继承了人的属性与行为,当然学生有自己的特征行为,比如学习做作业;
    
 现在,当我们需要去描述教师与学生各自的行为的时候, 我们可以分开来说"教师在授课",  "学生做作业",  但如果我们要站在抽象的角度,  也就是从教师与学生的父类"人"的角度, 来同时描述他们各自的行为时,我们怎么描述?"人在授课"?"人在做作业"?这是不是怪怪的很不合适?不合适的问题就在于, 对于行为主体,我们使用了抽象层次的东东"人",而对于行为本身, 我们却使用了具体的东东"授课"与"教书". 怎么解决呢? 那就需要解决抽象与具体的矛盾问题. 
既然是站在抽象在角度来描述,那我们把行为抽象一下,不就能同时描述了吗?比如"人在做事"(教师授课与学生做作业都可以说成人在做事),这样就解决了抽象层次与具体层次之间的矛盾.

到了这一步, 我们可以把两个描述: "教师在做事", "学生在做事" 两者统一为"人在做事",
然后, 我们可以在"教师"的"做事"行为中去调用教师自己的特征行为"授课",
在"学生"的"做事"行为中去调用学生自己的特征行为"做作业", 
所以,当调用"人"去"做事"的时候,如果这个人是教师,那他所做的事实际上就是"教书",
如果这个人是学生,那他所做的事实际上就是"做作业".
也就是说在这里"人"是多态的, 在不同的形态时,特征行为是不一样的, 这里的"人", 同时有两种形态,一种是教师形态,一种是学生形态,所对应的特征行为分别是"授课"与"做作业".

完成上述的描述过程, 其实就是多态机制的体现.

多态, 就是站在抽象的层面上去实施一个统一的行为,到个体(具体)的层面上时, 这个统一的行为会因为个体(具体)的形态特征而实施自己的特征行为.

多态比起封装与继承来说要复杂很多, 上面的描述很简单, 不用去死抠多态两个字,
其实只要明白: 
能站在抽象的角度去描述一件事, 
而针对这件抽象的事, 对于每个个体(具体)又能找到其自身的行为去执行, 这就是多态.

* Java中普通代码块，构造代码块，静态代码块区别及代码示例
//执行顺序：（优先级从高到低。）静态代码块>mian方法>构造代码块>构造方法。

其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。

1 普通代码块
    //普通代码块：在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定--“先出现先执行”
		   public class CodeBlock01{
		         public static void main(String[] args){		            
		              {
		                int x=3;
		                System.out.println("1,普通代码块内的变量x="+x);    
		              }
		              
		             int x=1;
		             System.out.println("主方法内的变量x="+x);
		             
		             {
		                int y=7;
		                System.out.println("2,普通代码块内的变量y="+y);    
		             }
		           }
		     }
		     
		     /*
		     运行结果：
		     1,普通代码块内的变量x=3
		          主方法内的变量x=1
		          2,普通代码块内的变量y=7*/
		    
2 构造代码块	
	//构造块：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。

	public class CodeBlock02{
		{
		  System.out.println("第一代码块");    
		}
		
		public CodeBlock02(){
			System.out.println("构造方法");
			}
			
			{
			  System.out.println("第二构造块");
			}
		  public static void main(String[] args){
			  new CodeBlock02();
			  new CodeBlock02();
			  new CodeBlock02();
			   
		}
	}    

	/*
	*
	执行结果：
	第一代码块
	第二构造块
	构造方法
	第一代码块
	第二构造块
	构造方法
	第一代码块
	第二构造块
	构造方法*/
	
3 静态代码块
	//静态代码块:在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。
	//如果类中包含多个静态代码块，那么将按照"先定义的代码先执行，后定义的代码后执行"。
	//注意：1 静态代码块不能存在于任何方法体内。2 静态代码块不能直接访问静态实例变量和实例方法，需要通过类的实例对象来访问。


	class Code{
		{
		  System.out.println("Code的构造块");
		}
		
		static{
			System.out.println("Code的静态代码块");
			}
			
		public Code(){
			System.out.println("Code的构造方法");
			}
		}
		
		
	public class CodeBlock03{
		 {
		  System.out.println("CodeBlock03的构造块");    
		 }
		 
		 static{
			System.out.println("CodeBlock03的静态代码块");
			}
			
			public CodeBlock03(){
				 System.out.println("CodeBlock03的构造方法");
				}
			
		  public static void main(String[] args){
				System.out.println("CodeBlock03的主方法");
				new Code();
				new Code();
				new CodeBlock03();
				new CodeBlock03();
			  }
		}
	/*
	CodeBlock03的静态代码块
	CodeBlock03的主方法
	Code的静态代码块
	Code的构造块
	Code的构造方法
	Code的构造块
	Code的构造方法
	CodeBlock03的构造块
	CodeBlock03的构造方法
	CodeBlock03的构造块
	CodeBlock03的构造方法
	*/    
